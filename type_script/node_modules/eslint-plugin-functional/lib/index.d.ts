// Generated by dts-bundle-generator v9.5.1

import { NamedCreateRuleMeta } from '@typescript-eslint/utils/eslint-utils';
import { FlatConfig, RuleModule } from '@typescript-eslint/utils/ts-eslint';
import { Immutability } from 'is-immutable-type';
import { TypeDeclarationSpecifier } from 'ts-declaration-location';

type Docs = {
	/**
	 * Used for creating category configs and splitting the README rules list into sub-lists.
	 */
	category: "Currying" | "No Exceptions" | "No Mutations" | "No Other Paradigms" | "No Statements" | "Stylistic";
	recommended: "recommended" | "strict" | false;
	recommendedSeverity: "error" | "warn";
	requiresTypeChecking: boolean;
	url?: never;
};
type NamedCreateRuleCustomMeta<T extends string, Options extends ReadonlyArray<unknown>> = NamedCreateRuleMeta<T, Docs, Options>;
type Rule<MessageIds extends string, Options extends ReadonlyArray<unknown>> = RuleModule<MessageIds, Options, Docs> & {
	meta: NamedCreateRuleCustomMeta<MessageIds, Options>;
};
type IgnoreIdentifierPatternOption = Readonly<{
	ignoreIdentifierPattern?: ReadonlyArray<string> | string;
}>;
type IgnoreCodePatternOption = Readonly<{
	ignoreCodePattern?: ReadonlyArray<string> | string;
}>;
type IgnoreAccessorPatternOption = Readonly<{
	ignoreAccessorPattern?: ReadonlyArray<string> | string;
}>;
type IgnoreClassesOption = Readonly<{
	ignoreClasses: boolean | "fieldsOnly";
}>;
type IgnoreMapsAndSetsOption = Readonly<{
	ignoreMapsAndSets: boolean;
}>;
type IgnorePrefixSelectorOption = Readonly<{
	ignorePrefixSelector?: ReadonlyArray<string> | string;
}>;
type RawTypeSpecifier = {
	name?: string | string[];
	pattern?: string | string[];
	ignoreName?: string | string[];
	ignorePattern?: string | string[];
} & TypeDeclarationSpecifier;
type RawOverridableOptions<CoreOptions> = CoreOptions & {
	overrides?: Array<{
		specifiers?: RawTypeSpecifier | RawTypeSpecifier[];
		options?: CoreOptions;
		inherit?: boolean;
		disable?: boolean;
	}>;
};
declare const ruleNameScope = "functional";
declare const name = "functional-parameters";
declare const fullName: `${typeof ruleNameScope}/${typeof name}`;
type ParameterCountOptions = "atLeastOne" | "exactlyOne";
type CoreOptions = IgnoreIdentifierPatternOption & IgnorePrefixSelectorOption & {
	allowRestParameter: boolean;
	allowArgumentsKeyword: boolean;
	enforceParameterCount: ParameterCountOptions | false | {
		count: ParameterCountOptions;
		ignoreLambdaExpression: boolean;
		ignoreIIFE: boolean;
		ignoreGettersAndSetters: boolean;
	};
};
type RawOptions = [
	RawOverridableOptions<CoreOptions>
];
declare const errorMessages: {
	readonly restParam: "Unexpected rest parameter. Use a regular parameter of type array instead.";
	readonly arguments: "Unexpected use of `arguments`. Use regular function arguments instead.";
	readonly paramCountAtLeastOne: "Functions must have at least one parameter.";
	readonly paramCountExactlyOne: "Functions must have exactly one parameter.";
};
declare const rule: Rule<keyof typeof errorMessages, RawOptions>;
declare const name$1 = "immutable-data";
declare const fullName$1: `${typeof ruleNameScope}/${typeof name$1}`;
type CoreOptions$1 = IgnoreAccessorPatternOption & IgnoreClassesOption & IgnoreMapsAndSetsOption & IgnoreIdentifierPatternOption & {
	ignoreImmediateMutation: boolean;
	ignoreNonConstDeclarations: boolean | {
		treatParametersAsConst: boolean;
	};
};
type RawOptions$1 = [
	RawOverridableOptions<CoreOptions$1>
];
declare const errorMessages$1: {
	readonly generic: "Modifying an existing object/array is not allowed.";
	readonly object: "Modifying properties of existing object not allowed.";
	readonly array: "Modifying an array is not allowed.";
	readonly map: "Modifying a map is not allowed.";
	readonly set: "Modifying a set is not allowed.";
};
declare const rule$1: Rule<keyof typeof errorMessages$1, RawOptions$1>;
declare const name$2 = "no-class-inheritance";
declare const fullName$2: `${typeof ruleNameScope}/${typeof name$2}`;
type RawOptions$2 = [
	IgnoreIdentifierPatternOption & IgnoreCodePatternOption
];
declare const errorMessages$2: {
	readonly abstract: "Unexpected abstract class.";
	readonly extends: "Unexpected inheritance, use composition instead.";
};
declare const rule$2: Rule<keyof typeof errorMessages$2, RawOptions$2>;
declare const name$3 = "no-classes";
declare const fullName$3: `${typeof ruleNameScope}/${typeof name$3}`;
type RawOptions$3 = [
	IgnoreIdentifierPatternOption & IgnoreCodePatternOption
];
declare const errorMessages$3: {
	readonly generic: "Unexpected class, use functions not classes.";
};
declare const rule$3: Rule<keyof typeof errorMessages$3, RawOptions$3>;
declare const name$4 = "no-conditional-statements";
declare const fullName$4: `${typeof ruleNameScope}/${typeof name$4}`;
type RawOptions$4 = [
	IgnoreCodePatternOption & {
		allowReturningBranches: boolean | "ifExhaustive";
	}
];
declare const errorMessages$4: {
	readonly incompleteBranch: "Incomplete branch, every branch in a conditional statement must contain a return statement.";
	readonly incompleteIf: "Incomplete if, it must have an else statement and every branch must contain a return statement.";
	readonly incompleteSwitch: "Incomplete switch, it must be exhaustive or have an default case and every case must contain a return statement.";
	readonly unexpectedIf: "Unexpected if, use a conditional expression (ternary operator) instead.";
	readonly unexpectedSwitch: "Unexpected switch, use a conditional expression (ternary operator) instead.";
};
declare const rule$4: Rule<keyof typeof errorMessages$4, RawOptions$4>;
declare const name$5 = "no-expression-statements";
declare const fullName$5: `${typeof ruleNameScope}/${typeof name$5}`;
type RawOptions$5 = [
	IgnoreCodePatternOption & {
		ignoreVoid: boolean;
		ignoreSelfReturning: boolean;
	}
];
declare const errorMessages$5: {
	readonly generic: "Using expressions to cause side-effects not allowed.";
};
declare const rule$5: Rule<keyof typeof errorMessages$5, RawOptions$5>;
declare const name$6 = "no-let";
declare const fullName$6: `${typeof ruleNameScope}/${typeof name$6}`;
type RawOptions$6 = [
	IgnoreIdentifierPatternOption & {
		allowInForLoopInit: boolean;
		allowInFunctions: boolean;
	}
];
declare const errorMessages$6: {
	readonly generic: "Unexpected let, use const instead.";
};
declare const rule$6: Rule<keyof typeof errorMessages$6, RawOptions$6>;
declare const name$7 = "no-loop-statements";
declare const fullName$7: `${typeof ruleNameScope}/${typeof name$7}`;
type RawOptions$7 = [
	{}
];
declare const errorMessages$7: {
	readonly generic: "Unexpected loop, use map or reduce instead.";
};
declare const rule$7: Rule<keyof typeof errorMessages$7, RawOptions$7>;
declare const name$8 = "no-mixed-types";
declare const fullName$8: `${typeof ruleNameScope}/${typeof name$8}`;
type RawOptions$8 = [
	{
		checkInterfaces: boolean;
		checkTypeLiterals: boolean;
	}
];
declare const errorMessages$8: {
	readonly generic: "Only the same kind of members allowed in types.";
};
declare const rule$8: Rule<keyof typeof errorMessages$8, RawOptions$8>;
declare const name$9 = "no-promise-reject";
declare const fullName$9: `${typeof ruleNameScope}/${typeof name$9}`;
type RawOptions$9 = [
	{}
];
declare const errorMessages$9: {
	readonly generic: "Unexpected rejection, resolve an error instead.";
};
declare const rule$9: Rule<keyof typeof errorMessages$9, RawOptions$9>;
declare const name$10 = "no-return-void";
declare const fullName$10: `${typeof ruleNameScope}/${typeof name$10}`;
type RawOptions$10 = [
	{
		allowNull: boolean;
		allowUndefined: boolean;
		ignoreInferredTypes: boolean;
	}
];
declare const errorMessages$10: {
	readonly generic: "Function must return a value.";
};
declare const rule$10: Rule<keyof typeof errorMessages$10, RawOptions$10>;
declare const name$11 = "no-this-expressions";
declare const fullName$11: `${typeof ruleNameScope}/${typeof name$11}`;
type RawOptions$11 = [
	{}
];
declare const errorMessages$11: {
	readonly generic: "Unexpected this, use functions not classes.";
};
declare const rule$11: Rule<keyof typeof errorMessages$11, RawOptions$11>;
declare const name$12 = "no-throw-statements";
declare const fullName$12: `${typeof ruleNameScope}/${typeof name$12}`;
type RawOptions$12 = [
	{
		allowToRejectPromises: boolean;
	}
];
declare const errorMessages$12: {
	readonly generic: "Unexpected throw, throwing exceptions is not functional.";
};
declare const rule$12: Rule<keyof typeof errorMessages$12, RawOptions$12>;
declare const name$13 = "no-try-statements";
declare const fullName$13: `${typeof ruleNameScope}/${typeof name$13}`;
type RawOptions$13 = [
	{
		allowCatch: boolean;
		allowFinally: boolean;
	}
];
declare const errorMessages$13: {
	readonly catch: "Unexpected try-catch, this pattern is not functional.";
	readonly finally: "Unexpected try-finally, this pattern is not functional.";
};
declare const rule$13: Rule<keyof typeof errorMessages$13, RawOptions$13>;
declare const name$14 = "prefer-immutable-types";
declare const fullName$14: `${typeof ruleNameScope}/${typeof name$14}`;
type RawEnforcement = Exclude<Immutability | keyof typeof Immutability, "Unknown" | "Mutable"> | "None" | false | undefined;
type Option = IgnoreClassesOption & {
	enforcement: RawEnforcement;
	ignoreInferredTypes: boolean;
	ignoreNamePattern?: string[] | string;
	ignoreTypePattern?: string[] | string;
};
type CoreOptions$2 = Option & {
	parameters?: Partial<Option> | RawEnforcement;
	returnTypes?: Partial<Option> | RawEnforcement;
	variables?: Partial<Option & {
		ignoreInFunctions?: boolean;
	}> | RawEnforcement;
	fixer?: FixerConfigRawMap;
	suggestions?: SuggestionConfigRawMap;
};
type FixerConfigRaw = {
	pattern: string;
	replace: string;
};
type SuggestionsConfigRaw = Array<FixerConfigRaw & {
	message?: string;
}>;
type FixerConfigRawMap = Partial<Record<"ReadonlyShallow" | "ReadonlyDeep" | "Immutable", FixerConfigRaw | FixerConfigRaw[] | undefined>>;
type SuggestionConfigRawMap = Partial<Record<"ReadonlyShallow" | "ReadonlyDeep" | "Immutable", SuggestionsConfigRaw[] | undefined>>;
type RawOptions$14 = [
	RawOverridableOptions<CoreOptions$2>
];
declare const errorMessages$14: {
	readonly parameter: "Parameter should have an immutability of at least \"{{ expected }}\" (actual: \"{{ actual }}\").";
	readonly returnType: "Return type should have an immutability of at least \"{{ expected }}\" (actual: \"{{ actual }}\").";
	readonly variable: "Variable should have an immutability of at least \"{{ expected }}\" (actual: \"{{ actual }}\").";
	readonly propertyImmutability: "Property should have an immutability of at least \"{{ expected }}\" (actual: \"{{ actual }}\").";
	readonly propertyModifier: "Property should have a readonly modifier.";
	readonly propertyModifierSuggestion: "Add readonly modifier.";
	readonly userDefined: "{{ message }}";
};
declare const rule$14: Rule<keyof typeof errorMessages$14, RawOptions$14>;
declare const name$15 = "prefer-property-signatures";
declare const fullName$15: `${typeof ruleNameScope}/${typeof name$15}`;
type RawOptions$15 = [
	{
		ignoreIfReadonlyWrapped: boolean;
	}
];
declare const errorMessages$15: {
	readonly generic: "Use a property signature instead of a method signature";
};
declare const rule$15: Rule<keyof typeof errorMessages$15, RawOptions$15>;
declare const name$16 = "prefer-readonly-type";
declare const fullName$16: `${typeof ruleNameScope}/${typeof name$16}`;
type RawOptions$16 = [
	{
		allowLocalMutation: boolean;
		allowMutableReturnType: boolean;
		checkImplicit: boolean;
		ignoreCollections: boolean;
		ignoreClass: boolean | "fieldsOnly";
		ignoreInterface: boolean;
		ignorePattern?: string[] | string;
	}
];
declare const errorMessages$16: {
	readonly array: "Only readonly arrays allowed.";
	readonly implicit: "Implicitly a mutable array. Only readonly arrays allowed.";
	readonly property: "A readonly modifier is required.";
	readonly tuple: "Only readonly tuples allowed.";
	readonly type: "Only readonly types allowed.";
};
declare const rule$16: Rule<keyof typeof errorMessages$16, RawOptions$16>;
declare const name$17 = "prefer-tacit";
declare const fullName$17: `${typeof ruleNameScope}/${typeof name$17}`;
type RawOptions$17 = [
	{
		checkMemberExpressions: boolean;
	}
];
declare const errorMessages$17: {
	readonly generic: "Potentially unnecessary function wrapper.";
	readonly genericSuggestion: "Remove unnecessary function wrapper.";
};
declare const rule$17: Rule<keyof typeof errorMessages$17, RawOptions$17>;
declare const name$18 = "readonly-type";
declare const fullName$18: `${typeof ruleNameScope}/${typeof name$18}`;
type RawOptions$18 = [
	"generic" | "keyword"
];
declare const errorMessages$18: {
	readonly generic: "Readonly type using 'readonly' keyword is forbidden. Use 'Readonly<T>' instead.";
	readonly keyword: "Readonly type using 'Readonly<T>' is forbidden. Use 'readonly' keyword instead.";
};
declare const rule$18: Rule<keyof typeof errorMessages$18, RawOptions$18>;
declare const name$19 = "type-declaration-immutability";
declare const fullName$19: `${typeof ruleNameScope}/${typeof name$19}`;
declare enum RuleEnforcementComparator {
	Less = -2,
	AtMost = -1,
	Exactly = 0,
	AtLeast = 1,
	More = 2
}
type FixerConfigRaw$1 = {
	pattern: string;
	replace: string;
	message?: string;
};
type FixerConfig = {
	pattern: RegExp;
	replace: string;
	message?: string;
};
type SuggestionsConfig = FixerConfig[];
type RawOptions$19 = [
	IgnoreIdentifierPatternOption & {
		rules: Array<{
			identifiers: string | string[];
			immutability: Exclude<Immutability | keyof typeof Immutability, "Unknown">;
			comparator?: RuleEnforcementComparator | keyof typeof RuleEnforcementComparator;
			fixer?: FixerConfigRaw$1 | FixerConfigRaw$1[] | false;
			suggestions?: FixerConfigRaw$1[] | false;
		}>;
		ignoreInterfaces: boolean;
	}
];
declare const errorMessages$19: {
	readonly Less: "This type is declare to have an immutability less than \"{{ expected }}\" (actual: \"{{ actual }}\").";
	readonly AtLeast: "This type is declare to have an immutability of at least \"{{ expected }}\" (actual: \"{{ actual }}\").";
	readonly Exactly: "This type is declare to have an immutability of exactly \"{{ expected }}\" (actual: \"{{ actual }}\").";
	readonly AtMost: "This type is declare to have an immutability of at most \"{{ expected }}\" (actual: \"{{ actual }}\").";
	readonly More: "This type is declare to have an immutability more than \"{{ expected }}\" (actual: \"{{ actual }}\").";
	readonly userDefined: "{{ message }}";
};
type ImmutabilityRule = {
	identifiers: RegExp[];
	immutability: Immutability;
	comparator: RuleEnforcementComparator;
	fixers: FixerConfig[] | false;
	suggestions: SuggestionsConfig | false;
};
declare const rule$19: Rule<keyof typeof errorMessages$19, RawOptions$19>;
declare const rules: Readonly<{
	[name]: typeof rule;
	[name$1]: typeof rule$1;
	[name$3]: typeof rule$3;
	[name$2]: typeof rule$2;
	[name$4]: typeof rule$4;
	[name$5]: typeof rule$5;
	[name$6]: typeof rule$6;
	[name$7]: typeof rule$7;
	[name$8]: typeof rule$8;
	[name$9]: typeof rule$9;
	[name$10]: typeof rule$10;
	[name$11]: typeof rule$11;
	[name$12]: typeof rule$12;
	[name$13]: typeof rule$13;
	[name$14]: typeof rule$14;
	[name$15]: typeof rule$15;
	[name$16]: typeof rule$16;
	[name$17]: typeof rule$17;
	[name$18]: typeof rule$18;
	[typeDeclarationImmutability.name]: typeof typeDeclarationImmutability.rule;
}>;
declare const meta: {
	readonly name: "eslint-plugin-functional";
	readonly version: string;
};
declare const configs: Readonly<{
	all: FlatConfig.Config;
	lite: FlatConfig.Config;
	recommended: FlatConfig.Config;
	strict: FlatConfig.Config;
	off: FlatConfig.Config;
	disableTypeChecked: FlatConfig.Config;
	externalVanillaRecommended: FlatConfig.Config;
	externalTypeScriptRecommended: FlatConfig.Config;
	currying: FlatConfig.Config;
	noExceptions: FlatConfig.Config;
	noMutations: FlatConfig.Config;
	noOtherParadigms: FlatConfig.Config;
	noStatements: FlatConfig.Config;
	stylistic: FlatConfig.Config;
}>;
type EslintPluginFunctional = FlatConfig.Plugin & {
	meta: typeof meta;
	rules: typeof rules;
	configs: typeof configs;
};
declare const _default: EslintPluginFunctional;

declare namespace typeDeclarationImmutability {
	export { ImmutabilityRule, RuleEnforcementComparator, fullName$19 as fullName, name$19 as name, rule$19 as rule };
}

export {
	_default as default,
};

export {};
